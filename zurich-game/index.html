

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset='utf-8' />
    <title>Gaze Controlled Map Game</title>
    <link rel="shortcut icon" href="files/favicon.ico" type="image/x-icon">
   <!--  <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> -->

    <!-- original import
    <link rel = "stylesheet" href = "http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.css"/>
    <script src = "http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.js"></script>
 -->

    <!-- import of leaflet stylesheet of newer version  -->
     <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css"
   integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ=="
   crossorigin=""/>

     <!-- Leaflet script, has to be places after Leaflet's CSS -->
 <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js"
   integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ=="
   crossorigin=""></script>


    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <style>
        .sb1 {
  content: "";
  width: 0px;
  height: 0px;
  position: absolute;
  border-left: 10px solid #ffffff;
  border-right: 10px solid transparent;
  border-top: 10px solid #ffffff;
  border-bottom: 10px solid transparent;
  right: -20px;
  top: 6px;
}
    </style>
</head>



    <!--- Map box is one of the map option, you can choice any API that fits your needs  --->

    <!-- <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.4.1/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.4.1/mapbox-gl.css' rel='stylesheet' />-->



<body style="background-color:darkgrey;overflow-y:hidden;">

<!-- TODO: how to make the person load first because we need her first?
<div id="person">
<img id="bodyoftheperson" src="files/color2.png" alt="bodyoftheperson" style="position:absolute;bottom:100px;right:100px">
<img id="eyes" src="files/blue.png" alt="eyes" style="position:absolute;bottom:100px;right:100px">
<svg id="clothes" height="256" width="256" style="position:absolute;bottom:100px;right:100px">
   <polygon id="dress" points="90,170 145,170 130,100 115,110, 105,100" style="fill:blue;" />
    <polygon id="pants" points="105,185, 105,100, 108,100 108,105 127,105 127,100 131,100 131,185 120,185, 120,155 115,155 115,185" style="fill:blue;" />
</svg>


<img id="hair" src="files/browne.png" alt="hair" style="position:absolute;bottom:100px;right:100px">
    </div>
    -->

<div id="traindriving" style="display:none">
<video id="cab_ride_video" style="z-index: 1; position: absolute; top: 0" width=100% autoplay muted>
    <!-- Autoplay is only allowed when approved by the user, the site is activated by the user, or media is muted. -->
    <!-- this means it has to be muted by default and can only be unmuted once the user activated the site, or it might not play at all -->

  <source src="../durchmesserlinie_compressed.mp4" type="video/mp4">
  Your browser does not support HTML video.
</video>
    <script>


        // const stations = (require('files/faster_mode_stations.json'));  // TODO: problem because async?
        let available_width = screen.availWidth;
    let available_height = screen.availHeight;

         // localStorage variables
    let money = 399;
    let half_fare_expiry = 0;  // ms since 1970, since in the past, it means that the player has no valid half fare card
    let half_fare_price = 40;
    let travelcard_price = 400;
    let travelcard_expiry = 0;
    let locationonmap = [47.41186, 8.54384];
    let zoomed_in_zoomlevel = 15;
    let zoomed_out_zoomlevel = 13;
    let zoomlevel = zoomed_in_zoomlevel;  // because leaflet is too slow

    let diduserengage = false; // so the video isn't set to unmute every time somebody hits a key, probably better for performance



    const forcefrombeginning = true;
    if ((localStorage.hasOwnProperty("money")) && !forcefrombeginning){  // load money and everything else
        money = parseInt(localStorage.getItem("money"));
        half_fare_expiry = localStorage.getItem("half_fare_expiry");
        travelcard_expiry = localStorage.getItem("travelcard_expiry");
        locationonmap = [localStorage.getItem("long"), localStorage.getItem("lat")];  // localstorage can, by default, only handle strings.
        console.log("balance and savefiles request successful.");

    }
    else {
        console.log("started from beginning");
        localStorage.setItem("half_fare_expiry", half_fare_expiry);
        localStorage.setItem("travelcard_expiry", travelcard_expiry);
        localStorage.setItem("long", locationonmap[0]);
        localStorage.setItem("lat", locationonmap[1]);
        localStorage.setItem("mode", "intro");
        localStorage.setItem("money", money);
        console.log("saved in localstorage");
    }


  let startstop = 0;  // if unchanged, a train driving job will start at whatever is the first station
  let endstop=2; // initialise global value here that saves until which stop we want to drive later. 1 = main station, 2 = altstetten
  let interval = NaN;
  // let countdown = 0; // in seconds. outlook: this could be used to wait a bit before the train driver has to start driving.

</script>
<h1 style="position:absolute;right:10%;top:10%;z-index:100;color:white;background-color:black" id="tachometer">0 km/h</h1>
<h1 style="position:absolute;right:10%;bottom:50%;z-index:100;color:black;background-color:white" id="meter">0m</h1>
<h1 style="position:absolute;right:10%;top:20%;z-index:100;color:white;background-color:red" id="maxspeed">0 km/h</h1>
<!-- <h1 style="position:absolute;right:10%;bottom:10%;z-index:100;color:#004" id="state">N</h1> -->
<h1 style="position:absolute;left:10%;bottom:10%;z-index:100;color:#f00" id="0">EMERGENCY BRAKE</h1>
<h1 style="position:absolute;left:10%;bottom:20%;z-index:100;color:#ff0" id="1">B2</h1>
<h1 style="position:absolute;left:10%;bottom:30%;z-index:100;color:#ff0" id="2">B1</h1>
<h1 style="position:absolute;left:10%;bottom:40%;z-index:100;color:#fff" id="3">N</h1>
<h1 style="position:absolute;left:10%;bottom:50%;z-index:100;color:#6f6" id="4">A1</h1>
<h1 style="position:absolute;left:10%;bottom:60%;z-index:100;color:#6f6" id="5">A2</h1>
<h1 style="position:absolute;left:10%;bottom:70%;z-index:100;color:#6f6" id="6">A3</h1>
    <!-- <h1 style='position:absolute; left:30%; top:40%;"' id="command"></h1> -->
</div>


<div id = "map" style = "width:75vw; height:95vh; z-index: -1"></div>

<canvas id="imgCanvas" style="position:absolute;top:0;left:0;width:100%;"> </canvas>



<div id="travelcarddiv" style="border:1px solid #000;color:#fff;background-color:#f00;position:absolute;bottom:50%;right:2%;height:30%;width:20%;border-radius:8px;padding:10px">
    <h1 id="travelpass">No Travel Pass yet.</h1>
</div>
<div id="introdiv">
    <svg style="position:absolute;width:100%;height:100%;left:0;top:0;">
        <polygon points="0,0 100800,0 100800,55000 0,55000" style="fill:white;stroke:black;stroke-width:1"/>
        <text id="speech"></text>
    </svg>
</div>


<div id="feedbackdiv" style="position:absolute;top:0">
<h1 id="comment"></h1>
<h1 id="timeNeeded"></h1>
<h1 id="overSpeedLimit"></h1>
<h1 id="emergency brakes"></h1>
<h1 id="loosenBrakesAtHalt"></h1>
<h1 id="distance stop"></h1>
<h1 id="totalScore"></h1>
</div>


<script>
        class Marker {  // this is for markers with screen coordinates that we use for games etc. outside leaflet
            constructor(text, x_min, x_max, y_min, y_max, functionstring = '', aktiv = true, colour = '#00f', hotcolour = '#f00', potential = 0) {
                this.text = text;
                this.x_min = x_min;
                this.x_max = x_max;
                this.y_min = y_min;
                this.y_max = y_max;
                this.width = x_max - x_min;
                this.height = y_max - y_min;
                this.functionstring = functionstring;
                this.potential = potential;
                this.aktiv = aktiv;
                this.colour = colour;
                this.hotcolour = hotcolour;

                // let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                this.addText();
            }

                addText(text){  // wouldn't show so i used leaflet tooltips
                    let h = document.createElement("H1");
                    let textNode = document.createTextNode(text);
                    /*
                    textNode.style.position = "absolute";
                    textNode.style.top = 0;
                    textNode.style.left = 0;
                    textNode.width = "100vw";
                    textNode.height = "100vh";

                    h.appendChild(textNode);
                    document.body.appendChild(h);
                    h.style.position = "absolute";
                    h.style.zIndex = "1000000";
                    h.style.top = this.y_min;
                    h.style.left = this.x_min;
                    h.style.color = '#0f0';
                    console.log('added h');
                    */
                    // h.style.display = 'inline';

                }
                deactivate(){
                this.aktiv = false;

                // delete h;
                }
        }
    // traindriving sim script

    let msperloop = 20;
        var stick = 3;
        var speed = 0;


    let vid = document.getElementById("cab_ride_video");
    document.addEventListener("click", function() {
  vid.muted = false;
});
vid.playbackRate = speed;

let gameoverreason = "you were too fast" // we want this?
let controlstrings = ["EMERGENCY BRAKE", "B2", "B1", "N", "A1", "A2", "A3"];
const formatter = new Intl.NumberFormat("en-GB", { style: "decimal",  signDisplay: 'always' });





// let seconds_with_emergeny_brake = 0;



// let colors = [#f00, #ff0, #ff0, #fff, #6f6, #6f6, #6f6];
let colors = [[255, 0, 0], [255, 255, 0], [255, 255, 0], [255, 255, 255], [100, 250, 100], [100, 250, 100], [100, 250, 100]];
// let fontcolors = [[255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]];



/*
 if (!(marker.visited)){
                            marker.setStyle({color: 'rgb(255, ' + marker.potential.toString() + ', ' +  marker.potential.toString()});
                        } else {
                            marker.setStyle({color: 'rgb(' + Math.floor(127 + marker.potential/2).toString() + ', ' + marker.potential.toString() + ', '+ marker.potential.toString() + ')'});

                        }
 */

function schalten(){  // switching gears
  for (let i = 0; i < 7; i++){
    if (i == stick){

      document.getElementById(i.toString()).style.backgroundColor = "rgb("+colors[i][0].toString()+","+colors[i][1].toString()+","+colors[i][2].toString()+")";
      if (i >= 0){
       document.getElementById(i.toString()).style.color = "black";
      } else {
        document.getElementById(i.toString()).style.color = "white";
      }

    } else {
      document.getElementById(i.toString()).style.backgroundColor = null;
      document.getElementById(i.toString()).style.color = "rgb("+colors[i][0].toString()+","+colors[i][1].toString()+","+colors[i][2].toString()+")";

    }
  }
}

schalten();


  function codeHandler(equalto) {
            if (equalto == 'w'){
              stick = Math.min(stick + 1, 6);
            }

            if (equalto == 's'){
              stick = Math.max(stick - 1, 0);

            }

            if (gameover){
              stick = 0
            }
            schalten();

            }



let distance_s = 0;
let distance_m = 0;  // since start
let distance_to_higher = 0;
let distance_to_next_change = 0;




// quelle/source durchmesserlinie video: TrainspotterVideos https://www.youtube.com/watch?v=t7XXJmFlbS8
        // flight video: myself

let beginningtodeccelerate = 180;
//let end = 269;  // 4:27, wo er circa 2% der geschwindigkeit hat.
let korrekturfaktor = 1; // e.g. if 60 km/ instead of 120 km/h, it should be 2

let baselinespeed = 115; // km/h, this is the reference speed multiplicated below to estimate the speed of the train. besides that, it is used to make the video less loud when we drive slow
let mpsbaseline = baselinespeed / 3.6;
let currentmaxspeed = 0;

speedcheckpoints = []  //
speedcheckpoints.push([0, 0.9, 80, 442]); // second 0 of the video, the video has a relative speed of 0.9 in the video, from this checkpoint onswards, 80 km/h are allowed, elevation(schienenoberkante 442 meter über meer für schwerpunkt eines zuges etwa) in meters above sea level
speedcheckpoints.push([20, 0.9, 120, 442]);  // ab diesem checkpoint darf man, in fahrtrichtung, 120 fahren
speedcheckpoints.push([200, 0.8, 80, 390]);
speedcheckpoints.push([260, 0.0625, 0, 390]);
speedcheckpoints.push([296, 0.0625, 80, 390]);
speedcheckpoints.push([314, 0.125, 80, 390]);  // end of löwenstrasse
speedcheckpoints.push([340, 1, 120, 405]); // at 5:40 the speed is 120 km/h
speedcheckpoints.push([372, 1, 120, 424]); // kohlendreieckbrücke scheitel erreicht
speedcheckpoints.push([374, 1, 120, 424]); // kohlendreieckbrücke
speedcheckpoints.push([394, 1, 120, 402]); // zwischenbrücken
speedcheckpoints.push([440, 1, 120, 422]); // letzibrücke scheitel erreicht
speedcheckpoints.push([442, 1, 120, 422]); // letzibrücke
speedcheckpoints.push([456, 1, 120, 400]); // letzibrücke ende
speedcheckpoints.push([474, 1, 0, 399]);  // 473
speedcheckpoints.push([480, 1, 130, 398]); // at 8:00 the allowed speed is 130 km/h


/*
speeditup = 2;
if (speeditup != 1) {
  for (let checkpoint of speedcheckpoints) {
    checkpoint[1] = Math.max(0.0625, checkpoint[1] / speeditup);
  }
}
*/

    let stopped = [false, false];
let gottastop = [true, true];
let stops = [260, 474];

        class actionmarkeronmap {  // leaflet markers and their data. each of these actionmarkersonmap has a "rectangle", which is a leaflet polygon
        constructor(e_min, n_min, tooltipstring, functionstring='travelcard()', aktiv=true, colour='00f', heating_up=[1, 1, 0], potential=0, type="activity"){  // how do default values work that can be changed when creating?

                this.e_min = e_min;
                this.e_max = e_min + 0.02;
                this.n_min = n_min;
                this.n_max = n_min + 0.01;
                this.functionstring = functionstring;
                this.tooltipstring = tooltipstring;
                this.width = this.e_max - this.e_min;  // translate to pixel coordinates?
                this.height = this.n_max - this.n_min;
                this.potential = potential;
                this.aktiv = aktiv;
                this.colour = colour;
                this.heating_up = heating_up;
                this.aktiv = true;
                this.type = type;
                this.rectangleinput = [
            [this.n_min, this.e_min],
            [this.n_min, this.e_max],
            [this.n_max, this.e_max],
            [this.n_max, this.e_min]
        ]
            this.rectangle = L.polygon(this.rectangleinput);
            this.rectangle.setStyle({color: 'rgba(255,0,0,0)'});

            this.rectangle.bindTooltip("test", {
    permanent: true, direction: "center", // outlook: offset: L.point(0, -200)
}).openTooltip();                  // this is important not to forget


        }

        activate(type='activity', visited=false){
            var rectangle = this.rectangle;
            rectangle.addTo(map);  // show
            // this.aktiv = true; // make gaze interact with it (or just add or remove from iterated lists
            localthings.push(rectangle);
            localthings[0].setTooltipContent("walk");
            leafletMarkers.push(rectangle);
            this.rectangle.setTooltipContent(this.tooltipstring);


            rectangle.aktiv = true;
            rectangle.functionstring = this.functionstring;
            rectangle.tooltipstring = this.tooltipstring;
            rectangle.potential = 0;
            rectangle.e_min = this.e_min;
            rectangle.e_max = this.e_max;
            rectangle.n_min = this.n_min;
            rectangle.n_max = this.n_max;
            rectangle.x_min = this.e_min;
            rectangle.x_max = this.e_max;
            rectangle.y_min = this.n_min;
            rectangle.y_max = this.n_max;
            rectangle.type = type;
            rectangle.visited = false;


    }

    deactivate(){
            rectangle.removeControl(map);
            this.aktiv = false
    }

    }


    function getDistance(){  // main loop of train simulator


  distance_s = vid.currentTime;
  distance_to_next_change = 0;
  distance_m = 0;

  let lower = speedcheckpoints[0];
  let higher = speedcheckpoints[1];
  let changepoint = speedcheckpoints[1];

  for (let checkpoint of speedcheckpoints){
    if ((distance_s >= checkpoint[0]) || (checkpoint[2] == currentmaxspeed)){
      distance_to_next_change += (checkpoint[0] - lower[0]) * ((checkpoint[1] + lower[1]) / 2) * mpsbaseline; // seconds times avg speed in m/s
      lower = checkpoint;
    } else {
      distance_to_next_change += (checkpoint[0] - lower[0]) * ((checkpoint[1] + lower[1]) / 2) * mpsbaseline;
      changepoint = checkpoint;
      break;
    }
  }
  distance_m = 0;
  lower = speedcheckpoints[0];

  let slope = 0;

   for (let checkpoint of speedcheckpoints){
    if (distance_s >= checkpoint[0]){
      distance_m += (checkpoint[0] - lower[0]) * ((checkpoint[1] + lower[1]) / 2) * mpsbaseline; // seconds times avg speed in m/s

      distance_to_higher = distance_m;
      lower = checkpoint;
    } else {
      distance_to_higher += (checkpoint[0] - lower[0]) * ((checkpoint[1] + lower[1]) / 2) * mpsbaseline;
      slope =  (checkpoint[3] - lower[3]) / ((checkpoint[0] - lower[0]) * ((checkpoint[1] + lower[1]) / 2) * mpsbaseline);
      higher = checkpoint;
      break;
    }
  }
  let weightHigher = (distance_s - lower[0]) / (higher[0] - lower[0]);
  let relativespeed = (1 - weightHigher) * lower[1]  + weightHigher * higher[1];  // linear acceleration over time


  distance_m += (distance_s - lower[0]) * ((relativespeed + lower[1]) / 2) * mpsbaseline;


    if ((lower[1] == 0.0625) && (higher[1] == 0.0625)){ // if there is a stop in between, i guess we'd have to skip it faster... maybe plus 1 instead?
    vid.currentTime =  higher[0]; //b Math.min(higher[0], vid.currentTime + relativespeed * playbackspeed * 20);  // 10 * fps, as browser's maximum is 16.
  }


  let wasdriving = (speed > 0);
  speed -= (speed**2) * 0.00042; // luftwiderstand air resistance
  speed -= 0.00005; // rollwiderstand rolling resistance 0.0002
  speed -= (slope / (1 + slope**2)**0.5) * 9.81 * (msperloop / 1000) * (1 / mpsbaseline); // slope; since acceleration formula is in mps; convert by dividing and apply per second
  speed = Math.max(0, speed + (stick-3) * (0.48 * (1 / mpsbaseline) * (msperloop / 1000) / Math.max(1, Math.exp(speed-1))));
  if (stick == 0 || stick == 1){
    energy_used -= speed;
  } else if (stick==2){
    energy_used -= 0.5 * speed;
  } else {
    energy_used += ((stick - 3) * Math.max(1, Math.exp(speed-1)));
  }
  console.log("activebuttons.length: " + activebuttons.length);
  if (wasdriving && (speed==0)){
    stopped_with_min = Math.min(stopped_with_min, stick);
  }


  korrekturfaktor = 1 / relativespeed;

  vid.playbackRate = speed * korrekturfaktor;
  vid.volume = Math.min(1, vid.playbackRate);  // this is just a random approach to not play the sound when it is too slow and thus poor quality

  if ((speed * baselinespeed) < 1){
    document.getElementById("tachometer").innerHTML = Math.ceil(speed * baselinespeed) + " km/h";
  } else {
    document.getElementById("tachometer").innerHTML = Math.round(speed * baselinespeed) + " km/h";
  }


  if (changepoint[2] == 0){
    document.getElementById("meter").innerHTML = "In " + Math.floor(distance_to_next_change - (distance_m + 20)) + "m: STOP";
    if ((distance_to_next_change - distance_m) < 40){
      document.getElementById("meter").style.backgroundColor = "green";
      if (speed == 0){ // we stopped at a stop
        maxdistancefromstop = Math.max(maxdistancefromstop, Math.abs(Math.floor(distance_to_next_change - (distance_m + 20))));
        if (distance_s > stops[0]){  // the second stop
          stopped[1] = true;
          hideeverythingandshowevaluation();
        } else {  // the first stop
          stopped[0] = true;
          if (endstop == 1) {
            console.log("finished!");
            hideeverythingandshowevaluation();
          } else {
            console.log("we still have some travelling ahead of us!");
            console.log(endstop);
          }
        }
        setTimeout(() => {  vid.currentTime =  speedcheckpoints[speedcheckpoints.indexOf(changepoint)+1][0]; }, 100);

      }
    } else {
      document.getElementById("meter").style.backgroundColor = "white";
    }
  } else {
    document.getElementById("meter").style.backgroundColor = "white";
    document.getElementById("meter").innerHTML = "In " + Math.floor(distance_to_next_change - distance_m) + "m: " + changepoint[2] + " km/h";
  }


  if ((speed * baselinespeed) > 20 + lower[2]){  // 20 km/h too fast triggers an emergency brake and the game is over
    stick = 0;
    gameover = true;
    console.log("game over because too fast");
    schalten();  // this will cause an emergency brake
  }
  for (let i = 0; i < gottastop.length; i++){
    if (gottastop[i] && (!stopped[i] && distance_s > stops[i])){  // too far
      gameover = true;
      console.log("game over because overrun");
    }
  }
  if (Math.round(speed * baselinespeed) > lower[2]){
    document.getElementById("tachometer").style.color = '#ff0';
    overspeedlimit = Math.max(overspeedlimit, Math.round(speed * baselinespeed - lower[2]));
  } else {
    document.getElementById("tachometer").style.color = '#fff';
  }
  if (gameover){
    document.getElementById("meter").innerHTML = "GAME OVER!";
    /*
    if (speed == 0){
        continue_to_game();
        */ // we don't need this, since they already got the return to map button
    }

  document.getElementById("maxspeed").innerHTML = lower[2] + " km/h";
  currentmaxspeed = lower[2];

}


    document.getElementById("traindriving").style.display = "none";
    // let timescore = countdown;
    var gearupbutton = new Marker("Gear Up (Accelerate)", available_width * 0.15, parseInt(available_width * 0.4), parseInt(available_height * 0.1), parseInt(available_height * 0.4), 'codeHandler("w");');
    var geardownbutton = new Marker("Gear down (Brake)", available_width * 0.15, parseInt(available_width * 0.4), parseInt(available_height * 0.45), parseInt(available_height * 0.75), 'codeHandler("s");');

    var activebuttons = [];


let energy_used = 0;
let gameover = false;
let overspeedlimit = 0;
let maxdistancefromstop = 0;
let stopped_with_min = 4;
let then = Date.now();
let end = Date.now();
let timescore = 0;

function set_game(start=0, end=2, minutes=5){
    for (let marker of leafletMarkers){
        marker.aktiv = false;
    }
    speed = 0;
stick = 3;
gameover = false;
then = Date.now();
energy_used = 0;
stopped_with_min = 4;
overspeedlimit = 0;
maxdistancefromstop = 0;
    console.log('set game');
    gameover = false;
    document.getElementById("introdiv").style.display = "block";  // for the end so we can display results
    document.getElementById("traindriving").style.zIndex = "1000";

    gearupbutton.potential = 200;  // light it up at the beginning so the user can see it
    geardownbutton.potential = 200;
    gearupbutton.aktiv = true;
    geardownbutton.aktiv = true;
    activebuttons.push(gearupbutton);
    activebuttons.push(geardownbutton);
    buytravelcardbutton.text = "Return to Map";
    buytravelcardbutton.functionstring = "vid.playbackRate=0; document.getElementById('feedbackdiv').style.display = 'none'; clearInterval(interval); activebuttons.splice(activebuttons.length - 1); activebuttons.splice(activebuttons.length - 1); console.log('returning to map from train simulator'); buytravelcardbutton.text = \"Buy a Travel Card\";\n" +
        "      buytravelcardbutton.functionstring = \"travelcard()\"; document.getElementById('travelcarddiv').style.display = 'block'; continue_to_game()";


    document.getElementById("travelcarddiv").style.display = "none";
  document.getElementById("traindriving").style.display = "block";
  startstop = Math.min(start, 1);
  startstop = Math.max(startstop, 0);
  endstop = Math.max(end, startstop+1);  // at least start + 1
  endstop = Math.min(endstop, 2); // at most 2

    if (startstop == 0){
    vid.currentTime = 10;  // 10  ; 247 to debug
  } else if (startstop == 1){
    vid.currentTime = 296;  // 296, 380 to debug // TODO: set back to 296. should i ask her to do it?
    gottastop[0] = false;
  }
  if (end==1){
    gottastop[1] = false;
  }

  timescore = minutes * 60;
  console.log("objective(seconds): " + timescore);
  interval = setInterval(getDistance, msperloop);
  then = Date.now();
  energy_used = 0; // kWh

}

function hideeverythingandshowevaluation() {
    document.getElementById("traindriving").style.display = "none";
    document.getElementById(("feedbackdiv")).style.display = "block";
    gearupbutton.aktiv = false;
    geardownbutton.aktiv = false;

    console.log("hiding everything");
    clearInterval(interval);
    let score = 100 * (endstop - startstop);
    document.getElementById("comment").innerHTML = "Well Done! +" + score + " CHF";

    let now = Date.now();
    let time_needed = Math.floor((now - then) / 1000);

    timescore -= time_needed;
    document.getElementById("timeNeeded").innerHTML = "Time (" + time_needed + " seconds): " + formatter.format(timescore) + " CHF";
    score += timescore;
    document.getElementById("overSpeedLimit").innerHTML = "Speeding (" + overspeedlimit.toString() + " km/h): " + Math.ceil(-(overspeedlimit ** 2) / 10).toString() + " CHF";
    score -= Math.ceil(-(overspeedlimit ** 2) / 10)  // punishment for being too fast is rising quadratically, because being really too fast is much worse than to speed just a little bit
    console.log(overspeedlimit);

    /*
  document.getElementById("emergency brakes").innerHTML = "Emergency Brake Usage (" + seconds_with_emergeny_brake + " seconds): " + (- 5 * seconds_with_emergeny_brake) + " CHF";
  score -= 5 * seconds_with_emergeny_brake;  // delete and replace with energy usage?
  */
    document.getElementById("emergency brakes").innerHTML = "Energy cost: -" + Math.ceil(energy_used / 400) + " CHF";
    score -= Math.ceil(energy_used / 400);

    if (stopped_with_min >= 2) {
        document.getElementById("loosenBrakesAtHalt").innerHTML = "Smooth Stop (with " + controlstrings[stopped_with_min] + "): +20 CHF";
        score += 20;
    } else {
        document.getElementById("loosenBrakesAtHalt").innerHTML = "Hard Braking at Stop (with " + controlstrings[stopped_with_min] + "): " + (stopped_with_min - 1) * 20 + " CHF";
        score += (stopped_with_min - 1) * 20;
    }
    document.getElementById("distance stop").innerHTML = "Stopping precision (" + maxdistancefromstop.toString() + "m): +" + (20 - maxdistancefromstop).toString() + " CHF";
    score += (20 - maxdistancefromstop);
    console.log(maxdistancefromstop);
    document.getElementById("totalScore").innerHTML = "Paycheck: " + Math.max(score, 0) + " CHF";
    changeMoney(Math.max(score, 0));  // this should update the screen

    // we travelled to a new location in the meantime:
    if (endstop==1){
        locationonmap = [stations[3][1], stations[3][2]];
       setFocal(3); // hauptbahnhof
        console.log("you drove to hauptbahnhof yourself");
    } else if (endstop==2){
        locationonmap = [stations[5][1], stations[5][2]];
        console.log("you drove to altstetten yourself");
        setFocal(5); // altstetten
    } else {
        console.log("end: " + endstop);
    }
}

    // end of traindriving sim script
</script>


<script>


    localStorage.setItem("mode", "intro");

    let leafletMarkers = [];
    let stationpolygons = [];  // where we walk to
    let stationpolygons_zoomed_in = [];   // where we take the train to
    let localthings = [];
    let hs = [];


        // stationinfo    //["hardbrücke", 47.38518, 8.51725]

    let stations = [["Affoltern", 47.42089, 8.50878],
        ["Oerlikon", 47.41186, 8.54384],
        ["Stadelhofen", 47.36674, 8.54863],
        ["Hauptbahnhof", 47.379, 8.537],
        ['Airport', 47.450, 8.562],
        ['Altstetten', 47.392, 8.489],
        ];


    let canvas = document.getElementById("imgCanvas");
    let context = canvas.getContext("2d");
    canvas.style.zIndex = 30;  // finally :)
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;




    let chargingspeed = 0;
    if (!useButton){
        chargingspeed = 0;
    }





    for (let i = 0; i < stations.length; i++){
        let h = document.createElement("H1");
        let textNode = document.createTextNode("Hello" + i);
        h.appendChild(textNode);
        document.body.appendChild(h);
        h.style.position = "absolute";
        h.style.zIndex = "20";
        hs.push(h);
    }
    console.log('length of stations: ' + stations.length);
    console.log('length of hs: ' + hs.length);


    let mapOptions = {
        center: [47.395, 8.537],
        zoom: 13,
        zoomControl: false,
        attributionControl: false,
        closePopupOnClick: false,
        zoomSnap: 0.1,
        boxZoom: false,
        dragging: false,
        zoomAnimationTreshold: 10,
        keyboard: false,
    }

    // Creating a map object
   // let L = window.L;
    let map = new L.map('map', mapOptions);






    let highrise = new actionmarkeronmap(8.500, 47.379, "will be overwritten", functionstring="talking_to_ella(0)");
    let traindriveroerlikon = new actionmarkeronmap(8.55384, 47.41186, "Work as a train driver and drive to Hauptbahnhof", functionstring="set_game(0, 1, 5)");
   // let rocketpilotgig = new actionmarkeronmap(8.49878, 47.42089);
   // let cook = new actionmarkeronmap(47.36674, 8.54863);  control temperature
    // let memory
    // let puzzle solver
    // let destroy wood
    let traindriverhb = new actionmarkeronmap(8.547, 47.379, "Work as a train driver and drive to Altstetten", functionstring="set_game(1, 2, 5)");
    let flyfromzurich = new actionmarkeronmap(8.532, 47.450, "Fly to Tropical Beach - 400 CHF", functionstring="fly_there()");
    let flyfromokinawa = new actionmarkeronmap(122.9717323912761, 24.465405024709412, "Fly back to Switzerland", functionstring="fly_switzerland()");
    let letellapublish = new actionmarkeronmap(122.9467323912761, 24.465405024709412, "Let Ella Publish her Paper", functionstring="win()");





    /*
       [["Affoltern", 47.42089, 8.50878],
        ["Oerlikon", 47.41186, 8.54384],
        //["hardbrücke", 47.38518, 8.51725],
        ["Stadelhofen", 47.36674, 8.54863],
        ["Hauptbahnhof", 47.379, 8.537],
        ['Airport', 47.450, 8.562],
        ['Altstetten', 47.392, 8.489],
        ];



    <button onClick="set_game(0, 1, 5)">Oerlikon - Zürich HB</button>
    <button onClick="set_game(1, 2, 5)">Zürich HB - Altstetten</button>
    <button onClick="set_game(0, 2, 11)">Oerlikon - Altstetten</button>
    */

    highrise.activate('info');
    traindriveroerlikon.activate();
    traindriverhb.activate();
    flyfromzurich.activate();
    flyfromokinawa.activate();




    let infoNorth = new actionmarkeronmap(8.560, 47.455, "Talk to Angela", functionstring="infoNorth.rectangle.setTooltipContent('Ella is in the Highrise Complex. You should talk to her before flying to the Tropics.');");
    infoNorth.activate('info');

    function info_north() {
        hs[1].innerHTML = "Ganz im Süden ist Ella";
        hs[1].display = "block";
        infoNorth.rectangle.visited = true;

    }

    function win(){
        document.getElementById("introdiv").style.display = "block";
        hs[1].style.display = "inline";
        hs[1].innerHTML = "you win!";
    }


      function talking_to_ella(nr){
        switch(nr) {
  case 0:
      document.getElementById("ella").style.display = "block";
      for (let marker of leafletMarkers) {
          marker.aktiv = false;
      }
      document.getElementById("introdiv").style.display = "block";
        hs[1].style.display = "inline";
        hs[1].innerHTML = "Hello! Sorry that I was hiding from everyone! I didn't want to text you either, I was scared someone else could read it.";
        console.log(activebuttons.length);
        console.log(leafletMarkers.length);
        continuebutton.aktiv = true;
        buytravelcardbutton.aktiv = false;
        continuebutton.functionstring = "talking_to_ella(1)";
        activebuttons.push(continuebutton);
        break;
        case 1:
            hs[1].innerHTML = "The reason I'm hiding is that I plan to publish my paper on Consciousness Studies that could have big implications for certain stakeholders. I can't elaborate now, but maybe it is safer if I stay at your side? Maybe safest would be somewhere far away?";

      continuebutton.functionstring = "talking_to_ella(2)";
      break;

      case 2:

          letellapublish.activate();  // from now on ella follows us and when we go to the tropics, the field "let ella publish" will be visible
          document.getElementById("introdiv").style.display = "none";
          continuebutton.aktiv = false;
      buytravelcardbutton.aktiv = true;
      hs[1].style.display = "none";
      for (let marker of leafletMarkers) {
          marker.aktiv = true;
      }
      continuebutton.aktiv = false;
      activebuttons.splice(activebuttons.length - 1); // remove continue
      buytravelcardbutton.aktiv = true;




  default:
      console.log("received invalid nr value for talking to ella")

}
        }








    function fly_there() {

        if (money >= 400){
            changeMoney(-400);
            map.flyTo([24.465405024709412, 122.9717323912761], 14);
            then = Date.now();
            tropicalsound.pause();
            tropicalsound.play();

      }
    }

    function fly_switzerland() {
        tropicalsound.pause();
            map.flyTo([stations[4][1], stations[4][2]], zoomed_in_zoomlevel);
    }





    // Creating a Layer object
    let layer = new L.TileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png');

    // Adding layer to the map
    map.addLayer(layer);


    // stations are to take the train there, stationpolygons_zoomed_in are to walk there



    let quarter_circumference = 10000;  // km
    let km_n = quarter_circumference / 90;
    let km_e = quarter_circumference * Math.cos(stations[0][1] * Math.PI / 180) / 90;

    function kmTo(other_position){  // to estimate locally the distance in km to a E, N value pair
        return (((other_position[0]-locationonmap[0])*km_n)**2 + ((other_position[1]-locationonmap[1])*km_e)**2)**0.5
    }



    function zooming(index, goal) {
        map.setView(L.latLng(stations[index][1], stations[index][2]), goal);
        console.log("goal: " + goal);
        console.log("zoom level" + map.getZoom());
        console.log("zooming");
        zoomlevel = goal;

    }



    highrise.rectangle.setTooltipContent("Highrise Complex");





    var useGaze = false;  // var makes it global somehow
    var useButton = true;

        const elem = document.documentElement;


        function openFullscreen() {
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { /* Safari */
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { /* IE11 */
                elem.msRequestFullscreen();
            }
        }
        // openFullscreen();



        const tropicalsound = new Audio('files/Scandinavianz - Tropics.wav');  // author: 'Scandinavianz' on Soundcloud
        // sample code for playing audio file, delete it if you don't need it.

        ////////////////////////////////////////////////////////////////////////////////////

        var host = document.location.host;
        var pathname = document.location.pathname;
        pathname = pathname.split("/")[1] ;
        var interactive = false;
        var test = true;

        var active = false;

        /*---- The following are for connecting the eye tracker with this web page ----*/
        var webSocket = new WebSocket("ws://" + host + "/" + pathname +"/"+ "demo");
        webSocket.onopen = function(message) {
            processOpen(message);
        };
        webSocket.onclose = function(message) {
            processClose(message);
        };
        webSocket.onerror = function(message) {
            processError(message);
        };
        webSocket.onmessage = function(message) {
            processMessage(message);
        };

        function processOpen(message) {
            console.log("connected");
			startConnection();
        }

        function processClose(message) {
            console.log("Client disconnected");

        }

        function processError(message) {

        }

        function processMessage(message) {
            console.log(message);
            var scale = window.devicePixelRatio;
            var msg = JSON.parse(message.data);
            switch (msg.function) {
                case "draw_lens":
                    var x = transX(msg.x / scale); //transX(msg.x);
                    var y = transY(msg.y / scale); //transY(msg.y)
                    processGaze(x, y);
                    //webSocket.send(res);
                    console.log('processed gaze');
                    break;

            }
        }

		function startConnection(){
			var result = new Object();
			result.function = "ready";
			webSocket.send(String(JSON.stringify(result, null, 2)));
		}

        ////////////////////////////////////////////translate coordinates ////////////////////////////////////////


        function transX(x) {
            var borderWidth = (window.outerWidth - window.innerWidth) / 2;
            topleft_x = window.screenX + borderWidth;
            return (x - topleft_x);
        }

        function transY(y) {
            var borderWidth = (window.outerWidth - window.innerWidth) / 2;
            topleft_y = window.screenY + window.outerHeight - window.innerHeight - borderWidth;
            return (y - topleft_y);
        }

        /* ------ End of the part for connecting eye tracker ---- */
        let most_recent_x = 0;
        let most_recent_y = 0;

        function process(){
            if (!useGaze) {
                processGaze(most_recent_x, most_recent_y)
            }
        }

        if(!useGaze){
            document.addEventListener("mousemove", () => {
                most_recent_x = event.clientX; // Gets Mouse X
                most_recent_y = event.clientY; // Gets Mouse Y
               // processGaze(most_recent_x, most_recent_y); // simulate with mouse cursor
            });
            setInterval(process, 15);
        }

        // processGaze: This is a function that is being called once the gaze data come (x and y of the gaze point)

        const clWidth = document.documentElement.clientWidth;
        const clHeight = document.documentElement.clientHeight;

        document.addEventListener('keydown', (e) => {   // NICE!
            if (!e.repeat) {
                KeyDownHandler(e);
            }
            });

    document.addEventListener('mousedown', (e) => {   // NICE!
        adding_potential = true;
        });


        function changeMoney(amount){
            money = money + amount;
            drawGaze(most_recent_x, most_recent_y); // updateScreen if not done already by mode gaze
            localStorage.setItem("money", money);
        }
        let adding_potential = false;
        let buildup = '';

        function KeyDownHandler(event) {
            console.log(event);
            if (!diduserengage){
                vid.muted = false;  // the user hitting a key while the page is active most likely counts as an user interaction that lets us unmute the video without it being blocked by the browser
                diduserengage = true;
            }



            if ((event.key == 'g') && (buildup == 'i')){
                useGaze = (!useGaze);
            }
            if ((event.key == 'b') && (buildup == 'i')){
                useButton = (!useButton);
                chargingspeed = 0;
                if (!useButton){
                chargingspeed = 3;
                }
            }
              if (event.key == 'i'){
                buildup = 'i';
            }else {
                  buildup = '';
              }

            if ((event.keyCode == 77) || (event.keyCode == 109)) {// m is for money hack
                changeMoney(1);
                drawGaze(most_recent_x, most_recent_y); // updateScreen
            } else if ((event.key == 'Enter')&&(useButton)){ // j is for accelerating action
                adding_potential = true;
            } else if (event.key == 'c'){
                drawingCircle = !(drawingCircle);
            } else if (event.key == 'q'){  // change input mode, but only if i is pressed?


            } else if (event.key == 'w'){
                useButton = (!useButton);
            }
        }




    function setFocal(index){
        let distanceself = kmTo([stations[index][1], stations[index][2]]);
        console.log('to ' + stations[index][0] + ' it is ' + distanceself);


        let price = 0;
        let now_ms = Date.now();
        if (travelcard_expiry<now_ms){  // no travelcard
            if (distanceself < 0.1){  // no ticket
            price = 0;
        } else if (distanceself < 2){
            price = 2;
        } else {
            price = (2 + Math.floor(distanceself / 2) * 2);
        }
          if (half_fare_expiry>now_ms){
              price /= 2;
          }


          for (let i = 0; i < stations.length; i++){
              stationpolygons[i].setTooltipContent("Walk to " + stations[i][0] + " Station");

            stationpolygons_zoomed_in[i].setStyle({color: 'rgba(0,0,0,255)'});  // transparent
            stationpolygons[i].setStyle({color: 'rgba(0,0,0,0)'});
          }




          for (let i = 0; i < localthings.length; i++){
              localthings[i].setStyle({color: 'rgba(0,0,0,255)'});
          }

          hidehs();
        }


        leafletMarkers = leafletMarkers.filter(x => !(stationpolygons.includes(x)));
        for (let i = 0; i < stationpolygons_zoomed_in.length; i++) {
            leafletMarkers.push(stationpolygons_zoomed_in[i]);
            // makesome.errormwssagfe();
        }

        for (let i = 0; i < localthings.length; i++) {
            leafletMarkers.push(localthings[i]);

        }


        for (let i = 0; i < stationpolygons.length; i++) {
            stationpolygons[i].setStyle({color: 'rgba(0,0,0,0)'});  // transparent
        }


        // if (locationonmap[1]-stations[index][1])**2)
        if (price <= money) {
            zooming(index, zoomed_in_zoomlevel);
            changeMoney(-price)
            locationonmap = [stations[index][1], stations[index][2]];


        }
    }



    for (let index = 0; index < stations.length; index++) {
        let stationname = stations[index][0];


        let x = stations[index][2];  // east
        let y = stations[index][1];  // north

        let x_min = x - 0.02;
        let x_max = x + 0.02;
        let y_min = y - 0.01;
        let y_max = y + 0.01;

        // the following are smaller polygons, for when we are zoomed in and want to take a train
        let x_minbahn = x - 0.01;
        let x_maxbahn = x + 0.01;
        let y_minbahn = y - 0.005;
        let y_maxbahn = y + 0.005;

        // marker_data_hb = new Marker('hb', y-0.01)
        let rectangle = L.polygon([
            [y_min, x_min],
            [y_min, x_max],
            [y_max, x_max],
            [y_max, x_min]
        ],  self.id = stationname);
         // in alter leaflet version geht das nicht
        rectangle.bindTooltip("test", {                          // stations have a rectangle in stationpolygons with the same index and they have tooltips
    permanent: true, direction: "center" //                         ,  // outlook: offset L.point(..., ...) so we can read it without triggering it.
}).openTooltip();




        stationpolygons.push(rectangle);

        let bahnhof = L.polygon([
            [y_minbahn, x_minbahn],
            [y_minbahn, x_maxbahn],
            [y_maxbahn, x_maxbahn],
            [y_maxbahn, x_minbahn]
        ])
        stationpolygons_zoomed_in.push(bahnhof);



        rectangle.addTo(map);
        bahnhof.addTo(map);

        rectangle.x_min = x_min;
        rectangle.x_max = x_max;
        rectangle.y_min = y_min;
        rectangle.y_max = y_max;
        bahnhof.x_min = x_minbahn;
        bahnhof.x_max = x_maxbahn;
        bahnhof.y_min = y_minbahn;
        bahnhof.y_max = y_maxbahn;
        rectangle.n = y;
        rectangle.e = x;
        bahnhof.n = x;
        bahnhof.e = y;
        bahnhof.latlng = L.latLng(bahnhof.n, bahnhof.e);
        rectangle.latlng = L.latLng(rectangle.n, rectangle.e);
        rectangle.aktiv = true;  // to deactivate a rectangle, either set this to false or remove from list
        bahnhof.aktiv = true;
        rectangle.potential = 0;
        rectangle.type = "train";
        bahnhof.potential = 0;
        bahnhof.type = "train";

        rectangle.functionstring = "setFocal("+index.toString()+");";
        bahnhof.functionstring = "setOverview("+index.toString()+"); " +
            "locationonmap[0] = stations["+index.toString()+"][1]; locationonmap[1] = stations["+index.toString()+"][2];";
        bahnhof.setStyle({color: 'rgba(0,0,0,0)'});
        // let stations = L.layerGroup([rectangle_hb]);
        // leafletMarkers.push(stations);
        leafletMarkers.push(rectangle);

    }




        function setOverview(index) {
            locationonmap = [stations[index][1], stations[index][2]];  // [east, north]
            zooming(index, zoomed_out_zoomlevel);
            leafletMarkers = leafletMarkers.filter(x => !((stationpolygons_zoomed_in.includes(x)) || localthings.includes(x)));

            for (let i = 0; i < localthings.length; i++) {
                localthings[i].setStyle({color: 'rgba(0,0,0,0)'});  // transparent
            }

            update_tooltips();
        }


        function update_tooltips(){
        for (let i = 0; i < stations.length; i++) {
            stationpolygons_zoomed_in[i].setStyle({color: 'rgba(0,0,0,0)'});  // transparent
            stationpolygons[i].setStyle({color: 'rgba(0,0,0,255)'});
            leafletMarkers.push(stationpolygons[i]);


            let distanceself = kmTo([stations[i][1], stations[i][2]]);
            let price = 0;
            let now_ms = Date.now();


            let pricestring = " ";

            if (travelcard_expiry<now_ms) {  // no unlimited travelcard
                if (distanceself < 0.1) {  // no ticket needed
                    price = 0;
                } else if (distanceself < 2) {
                    price = 2;
                } else {
                    price = 2 + parseInt(distanceself / 2) * 2;
                }
                if (half_fare_expiry > now_ms) {
                    price /= 2;
                }

                    if (price > money) {
                        pricestring = pricestring + " - You can't afford a ticket."
                        leafletMarkers = leafletMarkers.filter(x => !(stationpolygons[i] == x));

                    } else {
                        pricestring = pricestring + " - " + price.toString() + " CHF";
                    }
                } else {
                    console.log("You have a travel card!");
                    console.log("travelcard expiry: " + travelcard_expiry);
                    console.log("date now: " + Date.now());

                }

                console.log("zoom: " + map.getZoom());
                if ((zoomlevel < zoomed_in_zoomlevel) && (kmTo([stations[i][1], stations[i][2]]) > 0.1)) {  // if we are on train taking level AND not close
                    stationpolygons[i].setTooltipContent("Train to " + stations[i][0] + pricestring) //  + " ("+kmTo([stations[i][1], stations[i][2]])+"km)");
                    console.log("showing price string");
                }
                else if (zoomlevel < zoomed_in_zoomlevel){  // if we are on train taking level but the area is where we are at, we can walk there, too
                    stationpolygons[i].setTooltipContent("Walk to " + stations[i][0]);
                }
                else {   // walk to the station itself
                    stationpolygons[i].setTooltipContent("Walk to " + stations[i][0] + "Station") // + " ("+kmTo([stations[i][1], stations[i][2]])+"km)"); // + kmTo([stations[i][1], stations[i][2]]));
                }

        }




    }


    function buy(indx) {  // 1 = halftax, 2 = travelcard
        let price = half_fare_price
        if (indx == 1){
            if ((half_fare_expiry < Date.now()) && (travelcard_expiry < Date.now())){
                if (money >= price){
                    changeMoney(-price);
                    half_fare_expiry = Date.now() + 1000 * 3600 * 24 * 365;  // a year
                    localStorage.setItem('half_fare_expiry', half_fare_expiry.toString())
                    document.getElementById('travelpass').innerHTML = "Half Fare Card";
                }
            }
        }
        if (indx == 2){
            price = travelcard_price;
            if (travelcard_expiry < Date.now()){
                price -= Math.max(0, Math.floor(((half_fare_expiry - Date.now()) / (1000 * 3600 * 24 * 365)) * half_fare_price));  // money back for other card
                if (money >= price){
                    changeMoney(-price);
                    travelcard_expiry = Date.now() + 1000 * 3600 * 24 * 365;  // a year
                    localStorage.setItem('travelcard_expiry', travelcard_expiry.toString());
                    document.getElementById('travelpass').innerHTML = "Unlimited Travel Card";
                }
            }
        }
        if (map.getZoom() < zoomed_in_zoomlevel){ // we have to update the tooltips to show the new prices
            update_tooltips();
        }
    }
     let continuebutton = new Marker("", available_width * 0.1, parseInt(available_width * 0.5), parseInt(available_height / 2), parseInt(available_height * 0.8), 'chargingspeed=1;hs[1].innerHTML="Well done! To accelerate things, you can also press Enter while looking at a rectangle...";' +
                    'continuebutton.functionstring="performintro(1)"');
   // continuebutton.style.zIndex = "2000000";

  let buytravelcardbutton = new Marker("Buy a Travel Card", Math.ceil(available_width * 0.8), Math.ceil(available_width), Math.ceil(available_height * 0.65), Math.ceil(available_height), "travelcard();");
   // continuebutton.style.zIndex = "2000000";

    function continue_to_game(){
        gearupbutton.deactivate();
        geardownbutton.deactivate();
        localStorage.setItem("mode", "normal");
        document.getElementById("traindriving").style.display = "none";

        chargingspeed = 0;
        if (!useButton){
            chargingspeed = 3;
        }
        hidehs();
        document.getElementById("introdiv").style.display = "none";
        continuebutton.aktiv = false;


                for (let marker of leafletMarkers) {
                    marker.aktiv = true;
                }
                let person = new Person();  // doesn't do anything at this moment besides hiding

                person.hide();
                drawGaze(most_recent_x, most_recent_y);
                if (activebuttons.length == 0){
                    activebuttons.push(buytravelcardbutton);
                }
                drawGaze(most_recent_x, most_recent_y); // update screen


    }




    function performintro(progress=0){
        setFocal(1); // oerlikon
        hs[1].style.display = "inline";




        switch (progress) {
            case 0:
                localStorage.setItem("mode", "challenge");
                activebuttons.push(continuebutton);
                hs[1].style.top = "100px";
                hs[1].style.left = "100px";
                hs[1].innerHTML = "Hello and Welcome to Zürich!<br><br> I hope you had a pleasant train ride.<br>When you're ready, look at the rectangle below for a few seconds."


                break;
            case 1:
                hs[1].innerHTML = "All around the map, there will be train stations in black, conversations in <span style='color:red'>red</span> and activities in <span style='color:green'>green</span>. By the way, have you seen our friend Ella? She also lives in Zurich but I haven't seen here in a while...";
                chargingspeed = 0;
                if (!useButton) {
                    chargingspeed = 2;
                }


                continuebutton.functionstring = "performintro(2)";
                continuebutton.addText("Go to Oerlikon");  //
                break;

            case 2: // continue to map, back to game
                localStorage.setItem("mode", "normal");
                activebuttons.splice(0);  // remove continuebutton
                drawGaze(most_recent_x, most_recent_y); // update screen
                continue_to_game();
                break;
        }
    }


    /* outlook: rocket challenge
    function rocketflight(){  // no gaze at all? one single button
        let y_of_zero = height * (3 / 4);
        let y = (height / 16) * (Math.random() + 1);
        let fuel = 1000;
        let speed = 0;
        let running = true;
        while (running){
            if (true){  // if enter is being pressed (even if continuously)
                if (fuel > 0){
                    fuel -= 1;
                    speed -= 2;  // upwards, towards smaller y
                    y += speed;
                }

            }
            speed += 1 // gravitation
            if (y >= y_of_zero){
                running = false;

            } if (speed > 10) { //
             // crash
            } else {
                changeMoney(20 + parseInt((fuel/50) - speed));  // payment for being an astronaut

            }

        }
    }
    */

  /* outlook: some conversation where travelcards are explained
    function didyouknow(){
                hs[1].innerHTML = "Did you know that you can buy travelcards right to the east of the central station?"
        }

   */




        // since clicking long on the commit button means we want it to happen anyway.
        let lat = 0;
        let long = 0;


        function clearMarkers() {
            for (let marker of leafletMarkers) {
                if (marker.aktiv) {
                    marker.aktiv = false;
                    marker.removeControl(map);
                }
            }
        }

         function hidehs(){
        for (let i = 0; i < hs.length; i++){
            hs[i].style.display= 'none';
        }
    }


    if (localStorage.getItem('half_fare_expiry') > Date.now()){
       document.getElementById('travelpass').innerHTML = "Half Fare <br>Card";
    }
    if (localStorage.getItem('travelcard_expiry') > Date.now()){
        document.getElementById('travelpass').innerHTML = "Unlimited Travel <br>Card";
    }

    function processGaze(x, y) {  // main loop

            let pixelPosition = [x, y];
            let longlat= map.layerPointToLatLng(pixelPosition);  // translate pixel coordinates to WGS84
            let lat = longlat.lat;
            let long = longlat.lng;


                for (let marker of activebuttons){
                    if (marker.aktiv && ((marker.x_min <= most_recent_x) && (most_recent_x <= marker.x_max)) && (((marker.y_min <= most_recent_y) && (most_recent_y <= marker.y_max)))) {
                        marker.potential += chargingspeed;


                        if (adding_potential) {
                            marker.potential += 500;  // 210;
                            adding_potential = false;
                            drawGaze(most_recent_x, most_recent_y); // updateScreen if not done already by mode gaze


                        }
                    } else {
                        marker.potential = Math.max(0, marker.potential - 5);
                        // marker.potential += 1; this worked here, this means the loop is active

                    }

                    if (marker.potential > 255) {
                        marker.potential = 0;
                        eval(marker.functionstring);
                        break;
                    }

                }



            if ((localStorage.getItem("mode") != "intro") && (localStorage.getItem("mode") != "challenge")) {
                for (let marker of leafletMarkers) {

                    if (marker.aktiv && ((marker.x_min <= long) && (long <= marker.x_max)) && (((marker.y_min <= lat) && (lat <= marker.y_max)))) {
                        marker.potential += chargingspeed;

                        if (adding_potential) {
                            marker.potential += 500;
                            adding_potential = false;
                            drawGaze(most_recent_x, most_recent_y); // updateScreen if not done already by mode gaze
                        }


                    } else {
                        marker.potential = Math.max(0, marker.potential - 5);
                    }
                    if (marker.potential > 255) {
                        marker.potential = 0;
                        eval(marker.functionstring);
                        break;
                    }
                    if (marker.type == "activity") {
                        marker.setStyle({color: 'rgb(' + marker.potential.toString() + ', 255, ' + marker.potential.toString() + ')'});

                    } else if (marker.type == "info") {
                        if (!(marker.visited)) {
                            marker.setStyle({color: 'rgb(255, ' + marker.potential.toString() + ', ' + marker.potential.toString()});

                        } else {
                            marker.setStyle({color: 'rgb(' + Math.floor(127 + marker.potential / 2).toString() + ', ' + marker.potential.toString() + ', ' + marker.potential.toString() + ')'});

                        }

                    } else {

                        marker.setStyle({color: 'rgb(' + marker.potential.toString() + ', ' + marker.potential.toString() + ', 0)'});
                    }
                }
            }

            adding_potential = false;
            drawGaze(x, y);  // update screen
            most_recent_x = x;
            most_recent_y = y;
            }


        let drawingCircle = false;
        function drawGaze(x, y) {
            context.font = "20px Arial";
            context.clearRect(0, 0, canvas.width, canvas.height);
            if (drawingCircle) {
                context.beginPath();
                context.arc(x, y, 20, 0, 2 * Math.PI);
                context.stroke();

                if (useGaze) {
                    context.fillText("Gaze ( " + x + " , " + y + " )", 10, 50);
                } else {
                    context.fillText("Mouse ( " + x + " , " + y + " )", 10, 50);
                }
            }

            for (let marker of activebuttons) {
                if (marker.aktiv) {
                    context.fillStyle = 'rgb(' + Math.floor(marker.potential).toString() + ', ' + Math.floor(marker.potential).toString() + ', 0)';
                    context.fillText(marker.text, marker.x_min, marker.y_min - 20);

                    context.fillStyle = 'rgba(' + marker.potential.toString() + ', ' + marker.potential.toString() + ', 0, 0.8)';
                    context.fillRect(marker.x_min, marker.y_min, marker.width, marker.height);
                    context.fillStyle = 'rgb(0,0,0)';
                }
            }

            if (localStorage.getItem("mode") !="intro"){
                 context.fillText((money + " CHF"), available_width-100, 50);
            }



        }







</script>


<!--
<img id="irishgirl" src="files/irish_girl.png" alt="irishgirl" style="position:absolute;bottom:100px;right:100px">
-->
<div id="ella" style="display:none" style="position:absolute; top:100px; right:300px; height:500px">
    <img id="bodyofella" src="files/color1.png" alt="bodyoftheperson" style="position:absolute;bottom:100px;right:100px">
<img id="eyesofella" src="files/blue.png" alt="eyes" style="position:absolute;bottom:100px;right:100px">
<svg id="clothesofella" height="256" width="256" style="position:absolute;bottom:100px;right:100px">
    <polygon id="dressofella" points="90,170 145,170 130,100 115,110, 105,100" style="fill:darkred;" />

</svg>

<img id="hairofella" src="files/blonde.png" alt="hair" style="position:absolute;bottom:100px;right:100px">

</div>



<div id="person">

<img id="bodyoftheperson" src="files/color2.png" alt="bodyoftheperson" style="position:absolute;bottom:100px;right:100px">
<img id="eyes" src="files/blue.png" alt="eyes" style="position:absolute;bottom:100px;right:100px">
<svg id="clothes" height="256" width="256" style="position:absolute;bottom:100px;right:100px">
    <!-- <polygon id="dress" points="90,170 145,170 130,100 115,110, 105,100" style="fill:blue;" /> -->
    <polygon id="pants" points="105,185, 105,100, 108,100 108,105 127,105 127,100 131,100 131,185 120,185, 120,155 115,155 115,185" style="fill:blue;" />
</svg>
<img id="hair" src="files/browne.png" alt="hair" style="position:absolute;bottom:100px;right:100px">
    </div>

<script>


  if (localStorage.getItem("mode") == "intro") {// anscheineind geht das erst nachdem der div erstellt wurde
console.log("performing intro");
    document.getElementById("introdiv").style.display = "block";
    hidehs();
    performintro();

  } else {
    document.getElementById("introdiv").style.display = "none";
    console.log("hid intro div");
    console.log(localStorage.getItem('mode'));
  }

  class Person{  // assign it later to a situation that needs a person.
      constructor(seed=0){
          this.seed = seed;
          //especially for intro
          this.bodyoftheperson = document.getElementById('bodyoftheperson');
          this.hair = document.getElementById('hair');
          this.eyes = document.getElementById('eyes');
          this.clothes = document.getElementById('clothes');
      }
      moveTo(x, y){

      }
      hide(){
          for (let item of [this.bodyoftheperson, this.hair, this.eyes, this.clothes]){
              item.style.display = "none";
          }
      }
      show(){

      }
  }


    class PersonAllgemein{  // assign it later to a situation that needs a person.
      constructor(east, north, seed=0){
          this.seed = seed;
          //hardcoded for intro
          this.bodyoftheperson = document.createElement("img");
          this.hair = document.createElement("img");
          this.eyes = document.createElement('img');
          this.clothes = document.createElement('svg');
          this.style = "position:absolute top:100px left:100px";
      }
      moveTo(x, y){

      }
      hide(){
          for (let item of [this.bodyoftheperson, this.hair, this.eyes, this.clothes]){
              item.style.display = "none";
          }
      }
      show(){

      }
  }




  function go_back_from_travelcard(){
      activebuttons.splice(activebuttons.length - 1); // remove travelcard option
      activebuttons.splice(activebuttons.length - 1); // remove travelcard option
      console.log("go_back_from_travelcard()");
      buytravelcardbutton.text = "Buy a Travel Card";
      buytravelcardbutton.functionstring = "travelcard()";
      console.log(activebuttons);
      continue_to_game();

  }



  function travelcard(){  // open travelcard menue
      document.getElementById("introdiv").style.display = "block";
      localStorage.setItem("mode", "challenge");

      for (let marker of leafletMarkers) {
                    marker.aktiv = false;
                }

      buytravelcardbutton.text = "Return to Map";
      buytravelcardbutton.functionstring = "go_back_from_travelcard()";
      let travelcardbutton = new Marker("get half price off all travel: "+half_fare_price.toString()+" CHF", available_width * 0.1, parseInt(available_width * 0.5), parseInt(available_height * 0.1), parseInt(available_height * 0.4), 'buy(1, 50); go_back_from_travelcard();');
      let halffarebutton = new Marker("get unlimited travel card: "+travelcard_price.toString()+" CHF", available_width * 0.1, parseInt(available_width * 0.5), parseInt(available_height * 0.5), parseInt(available_height * 0.8), 'buy(2, 500); go_back_from_travelcard();');

      activebuttons.push(travelcardbutton);
      activebuttons.push(halffarebutton);


  }

</script>

</body>

</html>


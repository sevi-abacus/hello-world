<!DOCTYPE html> 
<html lang="en">
<head>
    <title>Zugsimulator Zürich</title>
    <link rel="shortcut icon" href="files/favicon.ico" type="image/x-icon">
    <meta charset='utf-8' />
    <meta name="author" content="Severin Spörri">
    <meta keywords="Zugsimulator Zürcher S Bahn Durchmesserlinie">
  <style>
      body{
          font-family: "Helvetica";
      }
  button{
    width: 50%;
    height: 10%;
    position: relative;
    left: 25%;
    padding: 5vh;
    margin: 2vh;
  }
</style>
</head>
<body>
<div id="train-selection"></div>  <!-- TODO: make everything with real physical constants,
and learn from somewhere how motors accelerate and use energy at different speeds
preselection, or define yourself (with other variables adapting automatically).
 finally, we would need to give the big trains more money, since they also need more energy (or tell them amount of passengers and let them determine number of carts
 (maybe randomness and maybe even depending on last performance with time and breaking and empty seats, or given scenarios) -->
<div id="traindriving">
<video id="myVideo" width=100% autoplay>
  <!-- muted: <video id="myVideo" width=100% autoplay muted>  -->
  <source src="files/durchmesserlinie.mp4" type="video/mp4">  <!-- copyright des videos: https://www.youtube.com/user/TrainspotterVideos -->
  Your browser does not support HTML video.
</video>
<script>
  let startstop = 0;
  let endstop=2; // global variable
  let interval = NaN;
  let countdown = 0; // seconds
</script>
<h1 style="position:absolute;right:10%;top:10%;z-index:100;color:white;background-color:black" id="tachometer">0 km/h</h1>
<h1 style="position:absolute;right:10%;bottom:50%;z-index:100;color:black;background-color:white" id="meter">0m</h1>
<h1 style="position:absolute;right:10%;top:20%;z-index:100;color:white;background-color:red" id="maxspeed">0 km/h</h1>
<!-- <h1 style="position:absolute;right:10%;bottom:10%;z-index:100;color:#004" id="state">N</h1> -->
<h1 style="position:absolute;left:10%;bottom:10%;z-index:100;color:#f00" id="0">EMERGENCY BRAKE</h1>
<h1 style="position:absolute;left:10%;bottom:20%;z-index:100;color:#ff0" id="1">B2</h1>
<h1 style="position:absolute;left:10%;bottom:30%;z-index:100;color:#ff0" id="2">B1</h1>
<h1 style="position:absolute;left:10%;bottom:40%;z-index:100;color:#fff" id="3">N - press W to accelerate and S to brake</h1>
<h1 style="position:absolute;left:10%;bottom:50%;z-index:100;color:#6f6" id="4">A1</h1>
<h1 style="position:absolute;left:10%;bottom:60%;z-index:100;color:#6f6" id="5">A2</h1>
<h1 style="position:absolute;left:10%;bottom:70%;z-index:100;color:#6f6" id="6">A3</h1>
    <!-- <h1 style='position:absolute; left:30%; top:40%;"' id="command"></h1> --> <!-- // todo: centre and add variable and background color. press w to acclereate. or should we put this were meters at? -->
</div>



<div id="classicselection">
    <center><h1>Which section do you want to drive?</h1></center>
    <br>
  <button onclick="set_game(0, 1, 5)">Oerlikon - Zürich HB</button>
  <button onclick="set_game(1, 2, 5)">Zürich HB - Altstetten</button>
  <button onclick="set_game(0, 2, 11)">Oerlikon - Altstetten</button>

</div>
<h1 id="comment"></h1>
<h1 id="timeNeeded"></h1>
<h1 id="overSpeedLimit"></h1>
<h1 id="emergency brakes"></h1>
<h1 id="loosenBrakesAtHalt"></h1>
<h1 id="distance stop"></h1>
<h1 id="totalScore"></h1>



</body>
<script>
let msperloop = 15;
let speed = 0;
let stick = 3;

let vid = document.getElementById("myVideo");
vid.playbackRate = speed;
let gameover = false;
let gameoverreason = "you were too fast" // we want this?
let controlstrings = ["EMERGENCY BRAKE", "B2", "B1", "N", "A1", "A2", "A3"];
const formatter = new Intl.NumberFormat("en-GB", { style: "decimal",  signDisplay: 'always' });



let then = Date.now();

let seconds_with_emergeny_brake = 0;
let stopped_with_min = 4;
let overspeedlimit = 0;
let maxdistancefromstop = 0;
let energy_used = 0;

// let colors = [#f00, #ff0, #ff0, #fff, #6f6, #6f6, #6f6];
let colors = [[255, 0, 0], [255, 255, 0], [255, 255, 0], [255, 255, 255], [100, 250, 100], [100, 250, 100], [100, 250, 100]];
// let fontcolors = [[255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]];



/*
 if (!(marker.visited)){
                            marker.setStyle({color: 'rgb(255, ' + marker.potential.toString() + ', ' +  marker.potential.toString()});
                        } else {
                            marker.setStyle({color: 'rgb(' + Math.floor(127 + marker.potential/2).toString() + ', ' + marker.potential.toString() + ', '+ marker.potential.toString() + ')'});

                        }
 */

function schalten(){
  for (let i = 0; i < 7; i++){
    if (i == stick){
      document.getElementById(i.toString()).style.backgroundColor = "rgb("+colors[i][0].toString()+","+colors[i][1].toString()+","+colors[i][2].toString()+")";
      if (i > 3){
          document.getElementById("3").innerHTML = "N";  // they now seem to understand the controls
      }
      if (i >= 0){
       document.getElementById(i.toString()).style.color = "black";
      } else {
        document.getElementById(i.toString()).style.color = "white";
      }

    } else {
      document.getElementById(i.toString()).style.backgroundColor = null;
      document.getElementById(i.toString()).style.color = "rgb("+colors[i][0].toString()+","+colors[i][1].toString()+","+colors[i][2].toString()+")";

    }
  }
}

// TODO: check that baselinespeed isn't hardcoding shit
// TODO: ideally, we can put parameters in like power, air resistance factor
schalten();


  function KeyDownHandler(event) {
            if (event.key == 'w'){
              stick = Math.min(stick + 1, 6);
            }

            if (event.key == 's'){
              stick = Math.max(stick - 1, 0);

            }

            if (gameover){
              stick = 0
                if (event.key == 'r'){
                    location.reload();
                }
            }
            schalten();

            }


   document.addEventListener('keydown', (e) => {   // NICE!
            if (!e.repeat) {
                KeyDownHandler(e);
            }
            });

let distance_s = 0;
let distance_m = 0;  // since start
let distance_to_higher = 0;
let distance_to_next_change = 0;




 // vid.currentTime = 260;  // TODO: delete and adapt video by estimating speed by a few fixed points by an algorithm (maybe we have it in our notes somewhere)
// TODO: algorithmus adaptieren. lokaler faktor für verlangsamung des videos (je schneller es ist). linear (wenn man annimmt lineare beschleunigung).
// TODO: gewisse stellen überspringen mit if function
// TODO: photogrammetrisch erkennen? python library?
// quelle durchmesserlinie video: TrainspotterVideos https://www.youtube.com/watch?v=t7XXJmFlbS8

let beginningtodeccelerate = 180;
//let end = 269;  // 4:27, wo er circa 2% der geschwindigkeit hat. // TODO: wieso lädt es schneller wenn es hier ist?
let korrekturfaktor = 1; // e.g. if 60 km/ instead of 120 km/h, it should be 2

let baselinespeed = 115; // km/h
let mpsbaseline = baselinespeed / 3.6;
let currentmaxspeed = 0;

speedcheckpoints = []  //
speedcheckpoints.push([0, 0.9, 80, 442]); // sekunde 0, im video hat der zug relative geschwindigkeit 0.9, ab diesem checkpoint darf man, in fahrtrichtung, 80 fahren, schienenoberkante 442 meter über meer (für schwerpunkt eines zuges etwa)
speedcheckpoints.push([20, 0.9, 120, 442]);  // ab diesem checkpoint darf man, in fahrtrichtung, 120 fahren
speedcheckpoints.push([200, 0.8, 80, 390]);
speedcheckpoints.push([260, 0.0625, 0, 390]);
speedcheckpoints.push([296, 0.0625, 80, 390]);
speedcheckpoints.push([314, 0.125, 80, 390]);  // end of löwenstrasse
speedcheckpoints.push([340, 1, 120, 405]); // at 5:40 the speed is 120 km/h
speedcheckpoints.push([372, 1, 120, 424]); // kohlendreieckbrücke scheitel erreicht
speedcheckpoints.push([374, 1, 120, 424]); // kohlendreieckbrücke
speedcheckpoints.push([394, 1, 120, 402]); // zwischenbrücken
speedcheckpoints.push([440, 1, 120, 422]); // letzibrücke scheitel erreicht
speedcheckpoints.push([442, 1, 120, 422]); // letzibrücke
speedcheckpoints.push([456, 1, 120, 400]); // letzibrücke ende
speedcheckpoints.push([474, 1, 0, 399]);  // 473
speedcheckpoints.push([480, 1, 130, 398]); // at 8:00 the speed is 120 km/h


/*
speeditup = 2;
if (speeditup != 1) {
  for (let checkpoint of speedcheckpoints) {
    checkpoint[1] = Math.max(0.0625, checkpoint[1] / speeditup);
  }
}
*/


let stopped = [false, false];
let gottastop = [true, true];
let stops = [260, 474];

// wir halten. das ist ein bisschen ein problem für unser video. dieses zu editieren führt ebenfalls zu lücken.
// TODO: wir machen also folgendes: innerhalb von 20 meter anhalten, dann wird teleportiert






/*
let stops = [];
let distance_to_stop = 0;
for (let i = 1; i < speedcheckpoints.length; i++) {
  distance_to_stop += (speedcheckpoints[i][0] - speedcheckpoints[i-1][0]) * ((speedcheckpoints[i][1] + speedcheckpoints[i-1][1]) / 2) * mpsbaseline;
  if (speedcheckpoints[i][1] == 0.0625){
    stops.push(distance_to_stop);
  }
}

 */






function getDistance(){  // main loop

  distance_s = vid.currentTime;
  distance_to_next_change = 0;
  distance_m = 0;

  let lower = speedcheckpoints[0];
  let higher = speedcheckpoints[1];
  let changepoint = speedcheckpoints[1];

  for (let checkpoint of speedcheckpoints){
    if ((distance_s >= checkpoint[0]) || (checkpoint[2] == currentmaxspeed)){
      distance_to_next_change += (checkpoint[0] - lower[0]) * ((checkpoint[1] + lower[1]) / 2) * mpsbaseline; // seconds times avg speed in m/s
      lower = checkpoint;
    } else {
      distance_to_next_change += (checkpoint[0] - lower[0]) * ((checkpoint[1] + lower[1]) / 2) * mpsbaseline;
      changepoint = checkpoint;
      break;
    }
  }
  distance_m = 0;
  lower = speedcheckpoints[0];

  let slope = 0;

   for (let checkpoint of speedcheckpoints){
    if (distance_s >= checkpoint[0]){
      distance_m += (checkpoint[0] - lower[0]) * ((checkpoint[1] + lower[1]) / 2) * mpsbaseline; // seconds times avg speed in m/s

      distance_to_higher = distance_m;
      lower = checkpoint;
    } else {
      distance_to_higher += (checkpoint[0] - lower[0]) * ((checkpoint[1] + lower[1]) / 2) * mpsbaseline;
      slope =  (checkpoint[3] - lower[3]) / ((checkpoint[0] - lower[0]) * ((checkpoint[1] + lower[1]) / 2) * mpsbaseline);
      // console.log("slope: " + slope);  // shouldn't be more than 0.03 or we made some error
      higher = checkpoint;
      break;
    }
  }
  let weightHigher = (distance_s - lower[0]) / (higher[0] - lower[0]);
  let relativespeed = (1 - weightHigher) * lower[1]  + weightHigher * higher[1];  // linear acceleration over time


  distance_m += (distance_s - lower[0]) * ((relativespeed + lower[1]) / 2) * mpsbaseline;


    if ((lower[1] == 0.0625) && (higher[1] == 0.0625)){ // if there is a stop in between, i guess we'd have to skip it faster... maybe plus 1 instead?
    vid.currentTime =  higher[0]; //b Math.min(higher[0], vid.currentTime + relativespeed * playbackspeed * 20);  // 10 * fps, as browser's maximum is 16.
  }

  // TODO: was braucht welche einheiten  // TODO: fix energy used
  let wasdriving = (speed > 0);
  speed -= (speed**2) * 0.00042; // luftwiderstand air resistance
  speed -= 0.00002; // rollwiderstand rolling resistance
  // console.log(-(slope / (1 + slope**2)**0.5) * 9.81 * (msperloop / 1000) * (1 / mpsbaseline));
  speed -= (slope / (1 + slope**2)**0.5) * 9.81 * (msperloop / 1000) * (1 / mpsbaseline); // slope; since acceleration formula is in mps; convert by dividing and apply per second. what about baselinespeed??
  speed = Math.max(0, speed + (stick-3) * (0.48 * (1 / mpsbaseline) * (msperloop / 1000))) // todo: how does acceleration behave with different speeds in a locomitive. what are the limitations?
  // this is if motor gets less efficient: divide by / Math.max(1, Math.exp(speed)))); or somethign like that check
  if (stick == 0 || stick == 1){  // half the energy goes back, but emergency break doesn't add additional energy
    energy_used -= (speed * mpsbaseline); // TODO: add msperloop and make everything with real physical units and import real locomotive specs
  } else if (stick==2){
    energy_used -= 0.5 * (speed * mpsbaseline);
  } else {
    energy_used += (stick - 3) * (speed * mpsbaseline); // as for now, we have linear acceleration, and this is the energy input. some motor factor too? but the thing to the right doesn't make too much sense because
    // Math.max(1, Math.exp(speed-1))); exp(0) = -inf and not 1. should maybe be exp(speed) directly idk
  }
  console.log("energy used: " + energy_used);
  if (wasdriving && (speed==0)){
    stopped_with_min = Math.min(stopped_with_min, stick);
  }

// TODO: goal overrun also trigges emergency breaks or nah?
  korrekturfaktor = 1 / relativespeed;

  vid.playbackRate = speed * korrekturfaktor;
  vid.volume = Math.min(1, vid.playbackRate);

  if ((speed * baselinespeed) < 1){
    document.getElementById("tachometer").innerHTML = Math.ceil(speed * baselinespeed) + " km/h";
  } else {
    document.getElementById("tachometer").innerHTML = Math.round(speed * baselinespeed) + " km/h";
  }


  if (changepoint[2] == 0){
    document.getElementById("meter").innerHTML = "In " + Math.floor(distance_to_next_change - (distance_m + 20)) + "m: STOP";
    if ((distance_to_next_change - distance_m) < 40){
      document.getElementById("meter").style.backgroundColor = "green";
      if (speed == 0){ // we stopped at a stop
        maxdistancefromstop = Math.max(maxdistancefromstop, Math.abs(Math.floor(distance_to_next_change - (distance_m + 20))));
        if (distance_s > stops[0]){  // the second stop
          stopped[1] = true;
          hideeverythingandshowevaluation();
        } else {  // the first stop
          stopped[0] = true;
          if (endstop == 1) {
            console.log("finished!");
            hideeverythingandshowevaluation();
          } else {
            console.log("we still have some travelling ahead of us!");
            console.log(endstop);
          }
        }
        setTimeout(() => {  vid.currentTime =  speedcheckpoints[speedcheckpoints.indexOf(changepoint)+1][0]; }, 100); // TODO: play stopping sound from video, and only continue once its played

      }
    } else {
      document.getElementById("meter").style.backgroundColor = "white";
    }
  } else {
    document.getElementById("meter").style.backgroundColor = "white";
    document.getElementById("meter").innerHTML = "In " + Math.floor(distance_to_next_change - distance_m) + "m: " + changepoint[2] + " km/h";
  }


  if ((speed * baselinespeed) > 20 + lower[2]){  // 20 TODO: when should it trigger? 20 km/h? btw: 139.5 km/h already shows 140
    stick = 0;
    gameover = true;
    console.log("game over because too fast");
    schalten();
  }
  for (let i = 0; i < gottastop.length; i++){
    if (gottastop[i] && (!stopped[i] && distance_s > stops[i])){  // too far
      stick = 0;
      gameover = true;
      console.log("game over because overrun");
      schalten();
    }
  }
  if (Math.round(speed * baselinespeed) > lower[2]){
    document.getElementById("tachometer").style.color = '#ff0';
    overspeedlimit = Math.max(overspeedlimit, Math.round(speed * baselinespeed - lower[2]));
  } else {
    document.getElementById("tachometer").style.color = '#fff';
  }
  if (gameover){
    document.getElementById("meter").innerHTML = "GAME OVER - press R to reload";
  }
  document.getElementById("maxspeed").innerHTML = lower[2] + " km/h";
  currentmaxspeed = lower[2];

}


// vid.currentTime = 10; // TODO: 10 delete


// todo: fade
// TODO: delete part of the video (but that makes it more cumbersome to create new simulators)
// TODO: make performance worse for higher speeds (physics) and lower air resistance

// TODO: show meters
// for this, we would have to integrate over the whole thing.

// TODO: gaze based
// TODO: one option is to fade AFTER the train stopped, directly to the point where we wanna start.




document.getElementById("traindriving").style.display = "none";

let timescore = countdown;

function set_game(start=0, end=2, minutes=5){ // TODO: only start main loop and show things once this is called in mainpage.html
  document.getElementById("classicselection").style.display = "none";
  document.getElementById("traindriving").style.display = "block";
  // document.getElementById("command").innerHTML = "Departure in " + countdown + "seconds. Press 'w' to shift up."; TODO
  startstop = Math.min(start, 1);
  startstop = Math.max(startstop, 0);
  endstop = Math.max(end, startstop+1);  // at least start + 1
  endstop = Math.min(endstop, 2); // at most 2

    if (startstop == 0){
    vid.currentTime = 10;  // 10  ; 247 to debug
  } else if (startstop == 1){
    vid.currentTime = 296;  // 296, 380 to debug
    gottastop[0] = false;
  }
  if (end==1){
    gottastop[1] = false;
  }

  timescore += minutes * 60;
  interval = setInterval(getDistance, msperloop);
  then = Date.now();
  energy_used = 0; // kWh

}

function hideeverythingandshowevaluation(){
  document.getElementById("traindriving").style.display = "none";
  console.log("hiding everything");
  clearInterval(interval);
  let score = 100 * (endstop - startstop);
  document.getElementById("comment").innerHTML = "Well Done! +"+score+" CHF";

  let now = Date.now();
  let time_needed = Math.floor((now - then) / 1000);
  // timescore -= time_needed;
  timescore -= time_needed;
  document.getElementById("timeNeeded").innerHTML = "Time ("+time_needed+" seconds): " + formatter.format(timescore) + " CHF";
  score += timescore;
  document.getElementById("overSpeedLimit").innerHTML = "Speeding (" + overspeedlimit.toString() + " km/h): " + Math.ceil(- (overspeedlimit**2)/10).toString() + " CHF";
  score -= Math.ceil(- (overspeedlimit**2)/10)
  console.log(overspeedlimit);
  seconds_with_emergeny_brake = Math.ceil(seconds_with_emergeny_brake);
  /*
  document.getElementById("emergency brakes").innerHTML = "Emergency Brake Usage (" + seconds_with_emergeny_brake + " seconds): " + (- 5 * seconds_with_emergeny_brake) + " CHF";
  score -= 5 * seconds_with_emergeny_brake;  // delete and replace with energy usage?
  */
  document.getElementById("emergency brakes").innerHTML = "Energy cost: -" + Math.ceil(energy_used / 10000) + " CHF";
  score -= Math.ceil(energy_used / 10000);

  if (stopped_with_min >= 2){
    document.getElementById("loosenBrakesAtHalt").innerHTML = "Smooth Stop (with " + controlstrings[stopped_with_min] + "): +20 CHF" ;
    score += 20;
  } else {
    document.getElementById("loosenBrakesAtHalt").innerHTML = "Hard Braking at Stop (with " + controlstrings[stopped_with_min] + "): " +(stopped_with_min - 1)*20+" CHF";
    score += (stopped_with_min - 1) * 20;
  }
  document.getElementById("distance stop").innerHTML = "Stopping precision (" + maxdistancefromstop.toString() + "m): +" + (20 - maxdistancefromstop).toString() + " CHF";
  score += (20 - maxdistancefromstop);
  console.log(maxdistancefromstop);
  document.getElementById("totalScore").innerHTML = "Paycheck: " + Math.max(score, 0) + " CHF";

}
/*
<h1 id="comment"></h1>
<h1 id="timeNeeded"></h1>
<h1 id="overSpeedLimit"></h1>
<h1 id="emergency brakes"></h1>
<h1 id="loosenBrakesAtHalt"></h1>
<h1 id="distance stop"></h1>
<h1 id="totalScore"></h1>



let seconds_with_emergeny_brake = 0;
let stopped_with_min = 4;
let overspeedlimit = 0;
let maxdistancefromstop = 0;
 */
</script>
</html>
